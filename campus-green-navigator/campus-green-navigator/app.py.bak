# app.py
import streamlit as st
from data import campus_data
from utils.helpers import calculate_co2_grams, format_minutes
from components.points_system import init_points, calculate_points, add_points, redeem_reward, REWARDS
import pandas as pd
import joblib
import os

st.set_page_config(page_title="Campus Green Navigator", layout="wide")

# Initialize session
init_points()

# Sidebar
st.sidebar.title("Campus Green Navigator")
start = st.sidebar.selectbox("Start", options=list(campus_data.LOCATIONS.keys()), index=0)
end = st.sidebar.selectbox("End", options=[k for k in campus_data.LOCATIONS.keys() if k != start], index=0)
vehicle = st.sidebar.radio("Vehicle", options=["Car", "Bike", "Walk", "EV"], index=0)
eco_route_toggle = st.sidebar.checkbox("Prefer eco route", value=True)

st.sidebar.markdown("---")
st.sidebar.subheader("Your Points")
st.sidebar.metric("Points", st.session_state.points)

st.sidebar.markdown("### Redeem Rewards")
for rname, cost in REWARDS.items():
    if st.sidebar.button(f"Redeem: {rname} ({cost})"):
        ok, msg = redeem_reward(rname)
        if ok:
            st.sidebar.success(msg)
        else:
            st.sidebar.warning(msg)

# Find route combos
def find_route(start, end):
    for r in campus_data.ROUTES:
        if r["from"] == start and r["to"] == end:
            return r
        if r["from"] == end and r["to"] == start:
            return r
    return None

route = find_route(start, end)
if route is None:
    st.warning("No pre-defined route between selected points.")
    st.stop()

# Compare fast vs eco
fast = route["fast"]
eco  = route["eco"]

col1, col2 = st.columns(2)
with col1:
    st.header("Fast Route")
    st.write(f"Distance: {fast['distance_km']} km")
    st.write(f"Time: {format_minutes(fast['time_min'])}")
    st.write(f"Estimated CO2: {calculate_co2_grams(vehicle, fast['distance_km']):.0f} g")
with col2:
    st.header("Eco Route")
    st.write(f"Distance: {eco['distance_km']} km")
    st.write(f"Time: {format_minutes(eco['time_min'])}")
    st.write(f"Estimated CO2: {calculate_co2_grams(vehicle, eco['distance_km']):.0f} g")

# Carbon savings
co2_fast = calculate_co2_grams(vehicle, fast["distance_km"])
co2_eco  = calculate_co2_grams(vehicle, eco["distance_km"])
co2_savings = max(0.0, co2_fast - co2_eco)
time_diff = eco["time_min"] - fast["time_min"]

st.markdown("---")
st.subheader("Route Comparison")
st.metric("CO2 Savings (g)", f"{co2_savings:.0f}")
st.metric("Extra Time (min)", f"{time_diff:.0f}")

# Visualize CO2 savings
st.progress(min(1.0, co2_savings / 200.0))  # simple visual scale

# Points
if st.button("Take Eco Route / Claim Points"):
    pts = calculate_points(co2_savings, extra_minutes=max(0, time_diff))
    add_points(pts, reason=f"Eco-route {start}â†’{end}")
    st.success(f"You earned {pts} points! ðŸŽ‰")

# Quick ML parking prediction loader (if model available)
st.markdown("---")
st.header("Parking Occupancy Prediction (demo)")

MODEL_PATH = "ml/parking_model.joblib"
if os.path.exists(MODEL_PATH):
    try:
        model = joblib.load(MODEL_PATH)
        st.success("Parking model loaded.")
        from datetime import datetime, timedelta
        now = datetime.now()
        rows = []
        for i in range(6):
            t = now + timedelta(hours=i)
            hour = t.hour
            weekday = t.weekday()
            import numpy as _np
            hour_sin = _np.sin(2 * _np.pi * hour / 24.0)
            hour_cos = _np.cos(2 * _np.pi * hour / 24.0)
            day_sin = _np.sin(2 * _np.pi * weekday / 7.0)
            day_cos = _np.cos(2 * _np.pi * weekday / 7.0)
            is_weekend = int(weekday >= 5)
            X = [[hour_sin, hour_cos, day_sin, day_cos, is_weekend, 0]]  # not exam
            pred = model.predict(X)[0]
            rows.append({"hour": t.strftime("%Y-%m-%d %H:%M"), "predicted_occupancy": float(pred)})
        st.table(pd.DataFrame(rows))
    except Exception as e:
        st.error(f"Failed to load model: {e}")
else:
    st.info("Parking model not found. Run the training script to generate one (see README).")
